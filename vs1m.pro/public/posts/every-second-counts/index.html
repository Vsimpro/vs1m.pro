<!DOCTYPE html>
<html lang="en-us">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>vs1m.pro</title>
  <link rel="stylesheet" href="/css/style.css">
</head>
<body>
    
  <div class="main">
    
  <nav>
    <a class="back" href="/"> back to ./home </a>
  </nav>

    <div class="table-of-contents">
      <h2>
        Table of contents
      </h2>
      <ul id="table">
      </ul>
    </div>

    
  
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked ttu">
          
        Posts
      </aside><div id="sharing" class="mt3 ananke-socials"></div>
<h1 class="f1 athelas mt3 mb1">Every Second Counts</h1>
      
      
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><p>If you&rsquo;ve ever wondered how milliseconds could be used to expose secrets, this one is for you.</p>
<p>In this article, I dive into how timing based side-channel attacks can be leveraged in application security. I&rsquo;ll show you how tiny delays in system responses can leak valuable information, like open ports and database records. Let&rsquo;s walk through some theory, and real world examples on actual applications.</p>
<h3 id="why-i-find-this-subject-exciting">Why I find this subject exciting</h3>
<p>Hackers love to find &amp; exploit unconventional ways of using technology. The following stuff is no different.</p>
<p>When finding exploits, be it a computer system, a videogame, or a tabletop game, you must always consider what you have at hand. What resources, what tools, what information can we leverage? What data can we give, and what data can we get? What can we do with both?</p>
<p>In games of incomplete information (poker, counter-strike, cybersecurity) it&rsquo;s your task as a player to not only keep your information exposure to a minimum, but to try and gain information where possible.</p>
<p>Playing these games is exciting. What simple things can we use to gain knowledge, and how could we leverage that? When it comes to hacking, we always think about new clever ways to exploit systems. Do we leverage <em>every</em> piece of information we have to the fullest? For example, how long things take?</p>
<h2 id="introduction">What are time-based sidechannel attacks?</h2>
<p>To understand what time-based sidechannel attacks are, first we must understand what sidechannel attacks are.</p>
<p><code>&quot;.. a side-channel attack is any attack based on extra information  that can be gathered because of the fundamental way a computer protocol or algorithm is implemented, rather than flaws in the design of the protocol or algorithm itself.&quot;</code></p>
<p>Timing based sidechannel is a version of this, where we measure the amount it takes to do a certain computation. When programming, each line of code is translated into instructions for the CPU, when the code is ran. Some more directly than others, but it all comes down to calculations on the CPU.
Some of these calculations take longer time than others, for example comparing two strings to each other is much faster than checking if a string appears as a subset of another.</p>
<p>But string comparisons in the end are quite fast. There is an excellent video <a href="https://youtu.be/JW81H0R4Chg?si=PuUeqseJPqYuK_Fl">All in the timing: How side channel attacks work</a> explaining the basics, where it&rsquo;s mentioned that these calculations take several hundred nanoseconds. Unless you&rsquo;re in a very specific environment, measuring everything with the margin several hundred nanoseconds simply isn&rsquo;t possible.</p>
<p>When you start to introduce connections, reading, writing &amp; more data you can get up to milliseconds of time taken on different computations &amp; connections. These are things we can measure and leverage.</p>
<h2 id="related-work">Previous work (kiosk.vsim.xyz)</h2>
<p>For my <a href="https://kiosk.vsim.xyz/">kiosk.vsim.xyz</a> tooling, I tried to find a good way to determine if ports are open on devices just using JavaScript. If you want to read more into it, you can read the blogpost here: <a href="https://blog.vsim.xyz/">blog.vsim.xyz</a></p>
<p>Turns out, you can use http requests to determine if an port is open or not. Looking at the time it takes for the request to resolve implies if the port is open or not. How? If the port is open, and a service behind it responds or cuts the connection due to protocol mismatch, the time to resolve the request is relatively fast. If there is no service responding, the request takes a lot longer to resolve. If the time to resolve is <em>really</em> slow, we can deduct that the host is unreachable from the device you&rsquo;re running the scan on.</p>
<p>With just a simple measurement of how long a HTTP request takes we can determine if a host exists in a network, and what ports on it are open. To me, this is extremely cool.</p>
<p>Ever since creating that tool, I have been really curious about using time-based tricks to mine information out of systems. The following article comes from the effects of this &ldquo;nerd-snipe&rdquo; where I have been unable to let go of the concept.</p>
<h2 id="theory">Mining data with latencies, in theory</h2>
<p>I have prepared a database with mock data into it. We can execute a query to find a certain email from the database, mimicking an application looking for an user, for example. The search itself will take time, because the rows are not indexed. But the returning of the results is what is the most interesting here. In theory, if a query is empty, it resolves quicker than if the query returns data in it.</p>
<p>We can suspect that the time it takes for a query to resolve is different if a certain data exists. Using this mechanic, even if we&rsquo;re not explicitly told the result of a query, we can still determine that something exists in the database if the query runs between the backend receiving the request and responding to it. Let&rsquo;s create a mockup function to show this behaviour:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> flask <span style="color:#f92672">import</span> Flask, request
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@app.route</span>(<span style="color:#e6db74">&#34;/search&#34;</span>, methods<span style="color:#f92672">=</span>[ <span style="color:#e6db74">&#34;GET&#34;</span> ])
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_user</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># search?email=</span>
</span></span><span style="display:flex;"><span>    email <span style="color:#f92672">=</span> request<span style="color:#f92672">.</span>args<span style="color:#f92672">.</span>get(<span style="color:#e6db74">&#34;email&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># If email is given, search the DB for it</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> email:
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Note that even if we&#39;re not authenticated, the query is being ran</span>
</span></span><span style="display:flex;"><span>        result <span style="color:#f92672">=</span> query_database(email) 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Result given to authenticated user</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> is_authenticated():
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result, <span style="color:#ae81ff">200</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># We&#39;re not authenticated, so we don&#39;t see the result</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;Unauthorized&#34;</span>, <span style="color:#ae81ff">401</span>  
</span></span></code></pre></div><p>We&rsquo;re not authenticated, so on the surface it would seem that there is no way to check if the email we&rsquo;re looking for exists in the database. However, no matter what our authentication status is, the query is being ran. Because everything else in the function takes roughly the same time each run, the only variance to the time it takes to run the function comes from the database query. This means, that we can measure the time it takes to run the query, by measuring the time it takes from our request to the response coming from the backend.</p>
<p>&ldquo;Ok, coolbeans, does it work though?&rdquo; Yeah, we can demo this by creating a small application that works as described. If we now use the mock database created, and hook it to this API, we can see that emails that exist in the database give us different times to resolve than emails that do not exist in the database.</p>
<figure class="blog-img wide-img"><img src="/images/emails_latency.png">
</figure>

<p>And it seems to work! We can roughly see, which emails are registered and which are not. The latencies vary a lot in relation to each other, however. I suspect that it&rsquo;s not only because of normal variance in the system, but has to do somewhat also with the lengths of the emails. We can better determine if an email is used by modifying it slightly to one that&rsquo;s highly unlikely to exist, but not too dissimiliar from the original, and measure their latencies against each other. We will look into this later on this article.</p>
<p>Now that we have an understanding of how to peek under the surface, let&rsquo;s see if we can find a real application to test this with.</p>
<h2 id="techniques">Revealing secrets from beneath the surface, in practice</h2>
<p>Because of this new-found fascination in timing stuff, I happened to unlock a new neural link in my head and find the following example.</p>
<p>To understand the context, unless you&rsquo;re Finnish, I am going to have to explain what this site is. It&rsquo;s called irc-galleria, and it lives in irc-galleria.net. IRC-Galleria is a Finnish social media-like site that was originally created for users of IRC-chats to share photos and interact with each other. It used to be really popular in the early 2000s, offering features like user profiles, photo albums, comments, and forums. Over time though, its popularity declined due to the rise of global social media platforms that we all know like Facebook and Instagram.</p>
<p>It still exists today, but is mostly used by bots &amp; millenials. I was visiting it for nostalgia purposes, when I noticed something very interesting. You can browse the pictures posted to the site as a catalogue of twenty by visiting: <code>https://irc-galleria.net/pictures/new?page=1</code></p>
<p>Each page can be visited by adjusting the <code>?page</code> URL parameter. But as you visit some of the later pages, like <code>page=1337</code> or even <code>page=133337</code>, you&rsquo;ll notice that the website loads very, very slow. What&rsquo;s going on?</p>
<p>As we&rsquo;re dealing with a black-box, and can&rsquo;t pop the hood open and take a look at it ourselves, we&rsquo;re gonna have to hypothize. A sane way to do this cataloguing would be to take the photos that are in range <code>n..n+20</code>, where <code>n</code> is the page number. It could look something like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">FROM</span>  images
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">WHERE</span> image_id <span style="color:#f92672">&gt;=</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">SELECT</span>   image_id 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">FROM</span>     images 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">ORDER</span> <span style="color:#66d9ef">BY</span> image_id 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">LIMIT</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">OFFSET</span> <span style="color:#f92672">?</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">ORDER</span> <span style="color:#66d9ef">BY</span> image_id
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">LIMIT</span> <span style="color:#ae81ff">20</span>;
</span></span></code></pre></div><p>Where <code>offset</code> can be set to something like <code>(n*20) - 1</code>. For page 4, this would mean offset of 79. But if we look at the time it takes to resolve these requests, we can kinda guess something is off here.</p>
<figure class="blog-img"><img src="/images/IRC_Galleria_latency.png">
</figure>

<p>We can see that the resolve time of the request rises in accordance to the page number, which would implicate that the images are first all loaded into the memory, and then programmatically pruned to get the last 20. This is slow. It could look something like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>    per_page <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>
</span></span><span style="display:flex;"><span>    offset   <span style="color:#f92672">=</span> (page <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">*</span> per_page
</span></span><span style="display:flex;"><span>    results  <span style="color:#f92672">=</span> database_results[ :offset <span style="color:#f92672">+</span> per_page ][ <span style="color:#f92672">-</span>per_page: ]
</span></span></code></pre></div><p>While we can&rsquo;t get an actual look inside the hood, from the way the pages load we can guess-timate how the engine is built. This means we have indirect information exposure, and while it isn&rsquo;t that useful in this example, we can come up with cases where this kind of information exposure could be potentially &ldquo;a bad thing&rdquo;.</p>
<h3 id="note-about-the-irc-gallery">NOTE ABOUT THE IRC GALLERY</h3>
<p>So while getting the figure above, I went from ID 0 to ID 30,000 and noticed something peculiar. Around the pages where we cross autumn of 2011 with the picture dates, the gradual increase of the time it takes for the page to load jumps up to near 30, and stays almost at that until the end of the pages.</p>
<figure class="blog-img wide-img"><img src="/images/Anomaly.png">
</figure>

<p>I will be completely transparent with you &ndash; I don&rsquo;t know why this happens. My theory is, that the way the backend or database handles images past a certain point. This could be due to the storage for the images being elsewhere, as I said, I honestly have no idea. Until that point, which is around page <code>27331</code>, they do grow lineary though, so I do not think this completely invalidates the findings above. When I first came to find this, I only checked the last page &amp; the first page, interpolated and deemed it grew in increments that represented somewhat linear flow. As an apology, have this meme I made when I first found it:</p>
<figure class="blog-img wide-img"><img src="/images/FunnyLatencyMeme.png">
</figure>

<h2 id="attack-model">Can we make it a security issue?</h2>
<pre tabindex="0"><code>[TQN - 13/12/2024, 17:15]

what i mean is that real world scenarios are
usually too dirty for this kind of approach to work

its like making a semi conductor in a clean room
and then trying to replicate it in my dusty attic
</code></pre><p>After being kindly convinced that mining user-information &amp; other data out of real world, production applications would be impossible, I wanted to find an application where we could actually leverage this method for real world impact.</p>
<p>I decided to use a bugbounty engagement as the subject for this research. Unfortunately, even though the following example was &ldquo;accepted&rdquo; as a P5/Informational without the aim to fix it, public disclosure wasn&rsquo;t accepted. I will be referring to the vendor as <code>[REDACTED]</code>.</p>
<p>I had previously reported to <code>[REDACTED]</code> an email-enumeration from their <code>forgot your password?</code> functionality. Their API would produce an error on the site if the email was not in use, and display the correct <code>&quot;We've sent you an email to reset the password, if this email has been registered to an account&quot;</code> if an email was in use. Late 2024 <code>[REDACTED]</code> decided to build a new login system, and as such, this bug has been fixed.</p>
<p>After testing the new site for a bit, I noticed, that <code>[REDACTED]</code> sends out an email <em>every</em> time you request a password reset. We can create a pseudo-code of the mechanism in the backend:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>user_email <span style="color:#f92672">=</span> request<span style="color:#f92672">.</span>data[<span style="color:#e6db74">&#34;email&#34;</span>] <span style="color:#75715e"># Parse JSON from HTTP Request</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> email_registered( user_email ) <span style="color:#75715e"># Check the DB for the email</span>
</span></span><span style="display:flex;"><span>    send_password_reset_link( user_email ) <span style="color:#75715e"># Send out the link!</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Email not registered -- do nothing</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">...</span>
</span></span></code></pre></div><p>In both cases, the API response is the same, but an additional computational cost is added if the email is registered. The database query, admittedly, can be a bit too fast to notice a difference of with the added variance in latency that comes from multiple hops. But sending out an email? Slow!</p>
<p>Slow enough to reveal secrets? yeah! We can see, that there&rsquo;s a clear difference between requests:</p>
<figure class="blog-img"><img src="/images/api_latency.png">
</figure>

<p>We can see that with manual testing that the email that has been registered resolves in the API ~200ms slower than the email that has not been registered on the site. We don&rsquo;t even have to look at the response &ndash; as long as it&rsquo;s 200 &amp; accepted, we know they sent out an email if the address is valid. We can, through the time it takes to resolve the request, enumerate which emails are already registered on the site.</p>
<p>Dusty attic gains 1 point. Score is now one to nil.</p>
<p>Let&rsquo;s script this to prove we can use this to enumerate emails programmatically. First we need to create the reset request to the backend:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> requests
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#   Reset password </span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">send_reset_password</span>( email ):
</span></span><span style="display:flex;"><span>    url      <span style="color:#f92672">=</span> [REDACTED]<span style="color:#e6db74">&#34;/v1/api/reset-password&#34;</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    _json    <span style="color:#f92672">=</span> { <span style="color:#e6db74">&#34;email&#34;</span> : email } <span style="color:#75715e"># target email</span>
</span></span><span style="display:flex;"><span>    _headers <span style="color:#f92672">=</span> { <span style="color:#f92672">...</span> }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    response <span style="color:#f92672">=</span> requests<span style="color:#f92672">.</span>put( 
</span></span><span style="display:flex;"><span>        url     <span style="color:#f92672">=</span> url,
</span></span><span style="display:flex;"><span>        headers <span style="color:#f92672">=</span> _headers,
</span></span><span style="display:flex;"><span>        json    <span style="color:#f92672">=</span> _json  
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> response
</span></span></code></pre></div><p>After which we can measure the time it takes for the HTTP request to resolve. We can call the function and take a <code>time</code> before the call and after the call.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> time 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Get Latency of the request, in milliseconds.</span>
</span></span><span style="display:flex;"><span>start    <span style="color:#f92672">=</span> time<span style="color:#f92672">.</span>time() <span style="color:#f92672">*</span> <span style="color:#ae81ff">1_000</span> 
</span></span><span style="display:flex;"><span>response <span style="color:#f92672">=</span> send_reset_password( email )<span style="color:#f92672">.</span>text <span style="color:#75715e"># Reset-request function</span>
</span></span><span style="display:flex;"><span>stop     <span style="color:#f92672">=</span> time<span style="color:#f92672">.</span>time() <span style="color:#f92672">*</span> <span style="color:#ae81ff">1_000</span>
</span></span></code></pre></div><p>These latencies &amp; timings are of no use, if they&rsquo;re not stored. Let&rsquo;s handle that too:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>TIMINGS : dict <span style="color:#f92672">=</span> {}
</span></span><span style="display:flex;"><span><span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">global</span> TIMINGS
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Store results per target tested</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> email <span style="color:#f92672">not</span> <span style="color:#f92672">in</span> TIMINGS:
</span></span><span style="display:flex;"><span>    TIMINGS[ email ] : list <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>TIMINGS[ email ]<span style="color:#f92672">.</span>append( stop <span style="color:#f92672">-</span> start )
</span></span></code></pre></div><p>As I mentioned before, different length of strings take different times to handle in the backend. To ensure the different lengths of the emails don&rsquo;t interfere with the measurements, we must test an email against a baseline. We can create the baseline by changing a few characters in the email, still keeping it generally in tact, but trying to change it into a format that wouldn&rsquo;t appear organically. We can do this by for example changing 1 letter in the domain of the email. <code>doesntexist@gmail.com</code> would then become <code>doesntexist@1m4il.com</code>. Of course someone could register the domain, and create a list of emails, and then register to <code>[REDACTED]</code>&rsquo;s site with them, which would interfere with the testing.. but we can.. generally assume this hasn&rsquo;t happened.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">leetify</span>( email ): 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#   Change Email address into a one that&#39;s most likely non-existing.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#</span>
</span></span><span style="display:flex;"><span>    deconstructed <span style="color:#f92672">=</span> email<span style="color:#f92672">.</span>split( <span style="color:#e6db74">&#34;@&#34;</span> )
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Email should be as long as the one we&#39;re testing.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Longer emails take longer in the query from the DB.</span>
</span></span><span style="display:flex;"><span>    reconstructed  <span style="color:#f92672">=</span> deconstructed[ <span style="color:#ae81ff">0</span> ] <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;@&#34;</span>
</span></span><span style="display:flex;"><span>    reconstructed <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34;1&#34;</span> <span style="color:#f92672">+</span> deconstructed[<span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>::]<span style="color:#f92672">.</span>replace(<span style="color:#e6db74">&#34;a&#34;</span>, <span style="color:#e6db74">&#34;4&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> reconstructed
</span></span></code></pre></div><p>With already these functionalities it&rsquo;s possible to start looking at the differences between different emails. See this code for further implementation:</p>
<p><code>https://github.com/Vsimpro/esc-labs/blob/main/scripts/enumeration.py</code></p>
<p>We can then run the script against this live system, and see how accurate we can get. For the screenshot below I modified the script to check if the email is registered by making a separate list to compare to. It&rsquo;s indicated by the second column, stating True for registered and False for unregistered.</p>
<figure class="blog-img"><img src="/images/latency_script.png">
</figure>

<p>Looking at the results it gives, it&rsquo;s clear there&rsquo;s a way to differentiate between email addresses that are registered, and the ones that are not. The emails that are not registered either fall shy of 1.0, or are just barely on it. The emails that <em>are</em> registered produce values well over 1.25. <strong>Email enumeration achieved!</strong></p>
<h2 id="discussion">Possible mitigation?</h2>
<p>Let&rsquo;s take another look at what we can hypothize happening in the backend. Let&rsquo;s look at it in the context of a flask webserver function.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@app.route</span>(<span style="color:#e6db74">&#34;/register/&#34;</span>, methods<span style="color:#f92672">=</span>[ <span style="color:#e6db74">&#34;GET&#34;</span> ])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>    user_email <span style="color:#f92672">=</span> request<span style="color:#f92672">.</span>data[<span style="color:#e6db74">&#34;email&#34;</span>] <span style="color:#75715e"># Parse JSON from HTTP Request</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> email_registered( user_email ) <span style="color:#75715e"># Check the DB for the email</span>
</span></span><span style="display:flex;"><span>        send_password_reset_link( user_email ) <span style="color:#75715e"># Send out the link! </span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Return</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;Password reset sent if email has a registered user&#34;</span>, <span style="color:#ae81ff">200</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">...</span>
</span></span></code></pre></div><p>We can see that the part which is causing the measurable delay is the checking &amp; sending of the email. In theory, we could offload this in somewhat~ consistent time, for example pushing it to RabbitMQ or another job queue.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># File: app.py</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#   Take in the Email</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@app.route</span>(<span style="color:#e6db74">&#34;/register/&#34;</span>, methods<span style="color:#f92672">=</span>[ <span style="color:#e6db74">&#34;GET&#34;</span> ])
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>    user_email <span style="color:#f92672">=</span> request<span style="color:#f92672">.</span>data[<span style="color:#e6db74">&#34;email&#34;</span>] <span style="color:#75715e"># Parse JSON from HTTP Request</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Send email to be checked &amp; possibly send out the reset link</span>
</span></span><span style="display:flex;"><span>    message <span style="color:#f92672">=</span> json<span style="color:#f92672">.</span>dumps({ <span style="color:#e6db74">&#34;email&#34;</span>: user_email })
</span></span><span style="display:flex;"><span>    channel<span style="color:#f92672">.</span>basic_publish(
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>        body <span style="color:#f92672">=</span> message,
</span></span><span style="display:flex;"><span>        routing_key <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;email_queue&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Return</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;Password reset sent if email has a registered user&#34;</span>, <span style="color:#ae81ff">200</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># File: email-check.py</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#   Elsewhere, check if the email is registered and send out </span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#</span>
</span></span><span style="display:flex;"><span>channel<span style="color:#f92672">.</span>queue_declare(queue<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;email_queue&#34;</span>, durable<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Function to process the message</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">callback</span>(ch, method, properties, body):
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>    email_data <span style="color:#f92672">=</span> json<span style="color:#f92672">.</span>loads(body<span style="color:#f92672">.</span>decode())
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> email_registered( user_email ) <span style="color:#75715e"># Check the DB for the email</span>
</span></span><span style="display:flex;"><span>        send_password_reset_link( user_email ) <span style="color:#75715e"># Send out the link! </span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">...</span>
</span></span></code></pre></div><p>We must do the check &amp; sending of the email in a separate runtime, to off load the measurable computing time of these tasks. In an API endpoint, where the response doesn&rsquo;t change, this is possible. But what if the response changes based upon the parameters? Let&rsquo;s take a look at an earlier example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#a6e22e">@app.route</span>(<span style="color:#e6db74">&#34;/search&#34;</span>, methods<span style="color:#f92672">=</span>[ <span style="color:#e6db74">&#34;GET&#34;</span> ])
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_user</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># search?email=</span>
</span></span><span style="display:flex;"><span>    email <span style="color:#f92672">=</span> request<span style="color:#f92672">.</span>args<span style="color:#f92672">.</span>get(<span style="color:#e6db74">&#34;email&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># If email is given, search the DB for it</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> email:
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Note that even if we&#39;re not authenticated, the query is being ran</span>
</span></span><span style="display:flex;"><span>        result <span style="color:#f92672">=</span> query_database(email) 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Result given to authenticated user</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> is_authenticated():
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result, <span style="color:#ae81ff">200</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># We&#39;re not authenticated, so we don&#39;t see the result</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;Unauthorized&#34;</span>, <span style="color:#ae81ff">401</span>  
</span></span></code></pre></div><p>Fixing this function into a form that doesn&rsquo;t reveal any information to unauthenticated is relatively easy. If user is not authenticated, do not make the database query. It would look like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#a6e22e">@app.route</span>(<span style="color:#e6db74">&#34;/search&#34;</span>, methods<span style="color:#f92672">=</span>[ <span style="color:#e6db74">&#34;GET&#34;</span> ])
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_user</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># We&#39;re not authenticated, so we don&#39;t see the result</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> is_authenticated():
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;Unauthorized&#34;</span>, <span style="color:#ae81ff">401</span>  <span style="color:#75715e"># Early return to reduce compute!</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># search?email=</span>
</span></span><span style="display:flex;"><span>    email <span style="color:#f92672">=</span> request<span style="color:#f92672">.</span>args<span style="color:#f92672">.</span>get(<span style="color:#e6db74">&#34;email&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># If email is given, search the DB for it</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> email:
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Note that even if we&#39;re not authenticated, the query is being ran</span>
</span></span><span style="display:flex;"><span>        result <span style="color:#f92672">=</span> query_database(email) 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Result given to authenticated user</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> result, <span style="color:#ae81ff">200</span>
</span></span></code></pre></div><p>We want to return early, to reduce the compute time. This control of flow minimizes the risk for this attack vector.</p>
<h2 id="conclusions">Conclusions</h2>
<p>We can reveal all kinds of things, if we really pay close attention to details!</p>
<p>By measuring the small details, we can infer how a backend processes a request, whether data exists in a database, or even what ports are open. These are &ldquo;attacks&rdquo; that do not rely on exploiting the traditional security flaws, but rather can be exploited through understanding the subtle behaviour of a system.</p>
<p>Even in the production environments, where latencies vary and network noise is greatly present, these techniques can still be observed and leveraged. Even in the dusty attics of real-world applications.</p>
<p>We can see that mitigation isn&rsquo;t impossible, but needs some thought. Trying to strive for code that runs on O(1) time is noble in any case, but can in this case serve the security as well.</p>
<p>Thank you for reading! Hope you learned something!</p>
<ul>
<li>Vs1m</li>
</ul>
<h2 id="notes">Bonus &amp; notes</h2>
<p>If you wish, you can try out these attacks yourself. I&rsquo;ve created some sample code &amp; labs to try these attacks against into this repository: <code>https://github.com/Vsimpro/esc-labs</code></p>
<p>I hope you have as fun with them as I have!</p>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    
    <a class="back" href="#"> back to up </a>
    
    <footer>
      <p>&copy; 2025 vs1m.pro. All Rights Reserved.</p>
    </footer>

  </div>
</body>
</html>
<script>

var tableOfContents = document.getElementById("table");
var headers         = document.getElementsByTagName("h2");

for (var i = 1; i < headers.length; i++) {
  
  
  let list_item       = document.createElement("li");
  let list_link      = document.createElement("a");


  let item_link       = headers[i].id;

  list_link.href      = "#" + item_link;
  list_link.innerText = headers[i].innerText;

  list_item.appendChild( list_link );
  tableOfContents.appendChild( list_item );
}

</script>
<style>

h1,h2,h3 {

  margin-top: 50px;

  font-size: x-large;
  
  width: auto;
  border-bottom: 1px solid black;
  
}

h1 {
  font-size: xx-large;
}

h3 {
  font-size: large;
  border-bottom: none;
  margin-top: 20px;
}

ul {
  list-style-type: " - ";
}

@media all and (orientation:portrait) {
  a {
      color: black;
      text-decoration: underline;
  }

  a:hover {
    font-weight: bolder;
  }

}

@media (orientation:portrait) and (max-width: 780px) {

  a {
      color: white;
      text-decoration: underline;
  }

}

</style>